The game being challenging confines largely to item 2, but also items 5 and 6 from the requirements in section \ref{gamedesign:selectionofgametype:importantstuff}.
The challenge in the game is the horde of enemies that chase the player, but if the enemies are all stuck behind a wall the challenge is non-existent.
Therefore the enemies need to be able to avoid obstacles and chase the players in a intelligent way.
This could be achieved by applying a pathfinding algorithm to the AI's behaviour.

\section{Pathfinding}
%Gridbased graph: 3984 nodes, 30450 edges
%Waypoint graph: 47 nodes, 624 edges

The pathfinding algorithm that we will be using is A* search pathfinding which has a runtime of $O(n*m)$, where n is the number of nodes that will be explored, m is the average number of neighbours in the graph, and we assume that the graph and heuristic operations take constant time \cite{AIG:Millington}.
%Other pathfinding possibilities would be BFS or floyd-warshall algorithm, but as BFS has a runtime of [] and floyd-warshall has a runtime of [] with a high memory usage, we will not be using them.

The first step in using an A* search algorithm, is to have a proper graph which represents the map in the game.
Our initial idea was to simply have each walkable square in the grid to be a node.
A node would then have up to eight connections which would point to a neighbour of that certain node with a cost of traversing to this node.
Possible neighbours would be four to each side of the node with a cost of 10 and four diagonal neighbours with a cost of 14, which is the length of the hypotenuse when the length of the catheti are 10.
This approach resulted in a very large graph which took a lot of time to create and traverse through, when running the algorithm on it.
An example of this can be seen in figure \ref{gridGraph} where you can see a map of size 64x64, the graph created for that map has 3984 nodes and 30450 edges.

\begin{figure}[H]
	\includegraphics[width=\textwidth]{figures/astar/gridGraph}
	\caption{Graph based on the grid of the map}
	\label{gridGraph}
\end{figure}

An optimisation for to this was to change the graph from being grid based to a waypoint graph.
We would create the graph based on the outer corners of the obstacles on the map, where the AI had to make a turn, as seen in figure \ref{waypointsNode}.
Each point would then do a check on every other point to see if it was in direct sight, if that was the case it was added as a neighbour and the cost for that edge would be the euclidean distance to that point.
A resulting graph can be seen in The  \ref{waypointgraph}.
This approach resulted in a much smaller graph with 47 nodes and 624 edges, thus improving both the creation of the graph and the traversal of it.

We can still improve this further by reducing the number of redundant waypoints.
All waypoints are looped through to find adjacent waypoints, meaning waypoints whose distance to each other is less or equal to one.
Those that are adjacent are then removed and a new waypoint is placed halfway between them.
This is illustrated in Figure \ref{waypointMerge}.
The resulting waypoints can be seen in Figure \ref{waypointOpt} with the graph in Figure \ref{waypointgraphOpt}.
Most notably, the amount of edges are significantly reduced.

\subsection*{Checking for players in line of sight}
Checking whether objects are in direct line of sight was initially done with Unity's raycasting system, but since this approach caused performance issues, we had to do further optimisations aiming for as few raycasts as possible.
Another approach would be to partition the map into rectangles.
Then when the enemy is in the same rectangle as the player we can simply go towards the player since the rectangle is convex.
Such partitions are generated while also generating the backdrop. Rectangles
are found using the same algorithm for finding rectangles for tiles. For
finding rectangles for partitions, we use an inverted version of the map
representing collidable walls. Doing so, we find rectangles for partitions as
shown in Figure~\ref{fig:partition_colliders_on_map}.

\begin{figure}[H]
        \includegraphics[width=0.9\textwidth]{figures/generating_levels/partition_colliders.png}
    \caption{Rectangles for partitions}\label{fig:partition_colliders_on_map}
\end{figure}

Once the partitions are made we give them trigger colliders which cover the size of the partitions.
These triggers are used to add and remove the partitions from an enemies' and players' list of partitions when a player enters the region.
A list of partitions is needed since the player and enemies can overlap with multiple partitions.
Without the list the order of \textit{onTriggerEnter} and \textit{onTriggerExit} would result in errors for instance the assigned partition being something completely different from the actual partition the enemy is in.


%%Running the A* search pathfinding from every enemy is very costly and as of such we want to do some alternative solutions when we can.
%Since our graph is based on waypoints it will not always return the shortest path to the player, for instance if the player is in direct line of sight, we should just walk towards him instead of going to a node first.
%First optimisation is to check whether the player is in direct sight which means we can go straight towards the player and not run any pathfinding algorithm.
\begin{figure}[H]
	\includegraphics[width=\textwidth]{figures/astar/waypoints}
	\caption{The placement of the waypoints}
	\label{waypointsNode}
\end{figure}

\begin{figure}[H]
	\includegraphics[width=\textwidth]{figures/astar/waypointsGraph}
	\caption{Graph based on the waypoints}
	\label{waypointgraph}
\end{figure}

\subsection*{Avoiding A* pathfinding}
Running an A* search pathfinding from every enemy is computationally costly which lead us to further optimise pathfinding.
First optimisation is to check whether the player is in the same partition as the enemy and if so the enemy can go straight towards the player and the enemy will be in hunting mode.
Hunting mode means the enemy can afterwards check the neighbouring partitions once the player runs out of sight.
If the player then escapes, meaning that the player is not in the same partition nor in the neighbouring partitions, we can still continue to walk towards the position where the player was last seen and once we have reached that position we look for the player again.
When the player's position is still not visible through the partitions, we run the pathfinding algorithm and follow the path until we have the player in sight again or reached the end of the path where we then have to run the algorithm again.

During the development process we found that having A* run during the runtime was costly.
Therefore, we moved the pathfinding to load time where it finds the shortest path for all the possible paths, and saves it in a hashtable.
This means that when a enemy cannot see the player, it checks the table for possible path and then simply follows it.


\begin{figure}[H]
	\includegraphics[width=\textwidth]{figures/astar/waypointMerge}
	\caption{Waypoint merging.}
	\label{waypointMerge}
\end{figure}

\begin{figure}[H]
	\includegraphics[width=\textwidth]{figures/astar/optimizedWaypoints}
	\caption{Waypoints after optimizations.}
	\label{waypointOpt}
\end{figure}

\begin{figure}[H]
	\includegraphics[width=\textwidth]{figures/astar/optimizedWaypointsGraph}
	\caption{Graph based on the waypoints after waypoint optimization.}
	\label{waypointgraphOpt}
\end{figure}


