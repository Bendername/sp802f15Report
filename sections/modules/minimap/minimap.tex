\todobrian{I know this should not go here. We need to come up with a structure
for individual implementation modules, like for the levels, minimap, loading
in things from json etc.}
In this chapter,  two different implementation of our in-game
``minimap'' representation are explored. The initial implementation was developed during prototyping sessions to show
the feasibility and usefulness of having a minimap in-game. This initial
implementation was however encumbered by sub-par performance,
for reasons which will be explained in more depth later in this chapter.

\section{Initial implementation}
The minimap implementation was initially inspired by \textit{bitmap-blitting}
techniques used in \textit{older} games\todoanders{a reference here could be nice}, which means that the general idea for
the implementation is to \textit{blit} - or plot - individual pixels to a
texture, corresponding to specific types of tiles or entities. This means that
there are several variable factors that needs to be considered:
\begin{itemize}
    \item The current position of the player
    \item The position of enemies within the game 
    \item What pixel-color to use when plotting the background and entities
\end{itemize}
Having all enemies and players managed in singleton-accessible instances,
makes it easy to satisfy the two first items on the list. The last item
however, we want to be able to define in a flexible way. This
has to do with the fact that any level can be loaded with any given
texture pack, meaning that walls, ground, grass and so on, appear differently
in the game, depending on the texture pack used.
We solved the problem by following the colors defined on the map in the texture pack. \todoanders{insert picture}
\\
\\
The colors used for plotting entities and the background on the minimap are
defined in a \texttt{PNG} image, accompanying the selected texture pack for that
level. The colors are parsed by index, e.g. the first pixel defines ground
color, second pixel defines grass color and etc.
\\
\\
The entities and background is blitted onto a texture at a shifted position, in
order to represent the players current position on the map. If entities such as
enemies and other players are within the players view bounds of the
texture, they are blitted onto the minimap textures as well. \todoanders{insert picture}
\\
\\
As mentioned in the beginning of this chapter, the implementation just
described proved to have performance implications, which was partly expected. 
This has to do with the performance overhead of blitting the whole texture every time something changed.
Whether that was due to the camera position or an entity that changed position.
This had a big cost of CPU time because the CPU had to recalculate each pixel on the map all the time.

\section{Optimized implementation}

