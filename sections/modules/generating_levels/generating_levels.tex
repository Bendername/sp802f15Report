In this chapter we explain the process of loading individual levels in our
game. This involves loading the level - encoded as an image in the PNG format -
parsing values from this format, and finally placing tiles in the game world
representing those values.

\section{Designing and loading levels}
Early in the development process, we established that for the type of game we
are making, it is important that we can quickly create levels of varying layout
and sizes, for various reasons, such as:
\begin{itemize}
    \item Our development process, in it being agile. This should afford quick
        turnarounds and iterations, therefore requiring that we can quickly
        produces content for our game, such as levels.
    \item Game balancing, requiring us to produce levels at a sufficient pace in
        order to quickly iterate on game balancing topics, such as strategies
        for a particular map layout.
    \item That we do not have a dedicated level designer on our team, whom we
        could allocate to finely tune and manually design levels.
\end{itemize}

From the above arguments, it is clear that we not only want to produce levels
in a quick manner, but also automate the process of placing
\texttt{gameobjects} in gameworld. While Unity's Editor can for many purposes
be thought of as a \textit{level editor}, we have chosen \textit{not} to use it
for designing levels for the following reasons:
\begin{itemize}
    \item Manually designing levels and placing gameobject in the Editor does
        not afford quick iterations, as required by our development process.
    \item The Editor does not afford easy refactoring of large levels, in that
        objects must be moved or replaced by hand. \textit{Large} is relative,
        but for our purposes it could be upwards +10.000 gameobjects.
    \item Individual levels would have to reside in individual \texttt{Scene}
        files, increasing the complexity of collaboration since scenefiles do
        not merge well in VCSs.
    \item A additional combinatorial complexity is introduced if we decide to
        also support different graphical appearances for objects in a level -
        what one could refer to as \textit{texture packs}. We would have
        to place a gameobject layout for each level for each texture pack.
\end{itemize}

While there are different approaches for circumventing the above
inconveniences, our solution is to encode the layout of each individual level
in an external file which is then loaded and interpreted. Historically, game
developers have often used this approach, usually encoded in some in-house
binary format. While we could have specified our own format, we have chosen to
encode the map in the PNG (Portable Network Graphics) for the following
reasons:
\begin{itemize}
    \item The PNG format is ubiquitous, in that there exists support for it
        almost anywhere, including in Unity3d - both in terms of API and the
        editor itself.
    \item It being ubiquitous means that we do not have to develop additional
        software in order to edit levels - most mainstream image editors
        support the PNG format.
    \item The PNG allows us to encode \textit{enough} information.
        \textit{Enough} being relative, but each colorchannel for each
        individual pixel offers 1 \texttt{byte} of information. With each pixel
        being encoded with RGBA (red, green, blue and alpha) channels, that
        gives us a total of 4 \texttt{bytes} of information.
\end{itemize}

Using the PNG format, it is then only a matter of specifying \textit{what} a
particular color should encode and interpreting that color when loading a
level. As an example, the following could specify how colors could be specified
to encode information about a level:
\begin{itemize}
    \item Black would be ground,
    \item green is grass,
    \item red is building floor, and
    \item yellow being building walls.
\end{itemize}

One obvious shortcoming from the above example is the lack of variation - maybe
one would like to be able to specify different types of walls or floors. This
could however be mitigated by either specifying more colors, by interpreting a
color randomly over a set or by interpreting a color differently depending on
the colors around it. To introduce variety into our levels, we use the latter
approach for some colors, which we will describe later in this chapter.
\\

Having decided on the format and encoded color values, we can design levels
such as seen in figure~\ref{fig:png_map}.

\begin{figure}[H]
    \centering
    \includegraphics{figures/generating_levels/map.png}
    \label{fig:png_map}
    \caption{A PNG image encoding a map}
\end{figure}

From figure~\ref{fig:png_map}, we can immediately see that there are some
patches of grass, a building in the middle of the map and some torn-down
buildings in the periphery of the map. Some individual pixels of cyan color can
be seen, which encode where monster should spawn. Likewise, a single white
pixel encode the exit point of the map, which is where players are required to
go to when the missions for this map have been completed. And last, a single
blue pixels encodes where the crafting table should be placed within the level.
\\
\\
Color values are then interpreted into distinct integer values in a
two-dimensional array, as seen in figure~\ref{fig:png_to_array}.
%thread carefully below...
\begin{figure}[H]
    \centering
    \label{fig:png_to_array}
\begin{tabular}{cc}
    {\footnotesize
\setlength{\tabcolsep}{4.5pt}
  \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|}
    \hline
    \cellcolor{black} & \cellcolor{black} & \cellcolor{black} &
    \cellcolor{black} & \cellcolor{black} & \cellcolor{red} &
    \cellcolor{red} & \cellcolor{red} & \cellcolor{red} &
    \cellcolor{red} \\ \hline
    \cellcolor{green} & \cellcolor{green} & \cellcolor{black} &
    \cellcolor{black} & \cellcolor{black} & \cellcolor{yellow} &
    \cellcolor{red} & \cellcolor{red} & \cellcolor{red} &
    \cellcolor{red} \\ \hline
    \cellcolor{green} & \cellcolor{green} & \cellcolor{green} &
    \cellcolor{black} & \cellcolor{black} & \cellcolor{yellow} &
    \cellcolor{red} & \cellcolor{red} & \cellcolor{red} &
    \cellcolor{red} \\ \hline
    \cellcolor{green} & \cellcolor{green} & \cellcolor{green} &
    \cellcolor{black} & \cellcolor{black} & \cellcolor{yellow} &
    \cellcolor{red} & \cellcolor{red} & \cellcolor{red} &
    \cellcolor{red} \\ \hline
    \cellcolor{green} & \cellcolor{green} & \cellcolor{green} &
    \cellcolor{black} & \cellcolor{black} & \cellcolor{yellow} &
    \cellcolor{yellow} & \cellcolor{red} & \cellcolor{red} &
    \cellcolor{yellow} \\ \hline
    \cellcolor{green} & \cellcolor{green} & \cellcolor{green} &
    \cellcolor{black} & \cellcolor{black} & \cellcolor{black} &
    \cellcolor{black} & \cellcolor{black} & \cellcolor{black} &
    \cellcolor{black} \\ \hline
    \cellcolor{green} & \cellcolor{green} & \cellcolor{green} &
    \cellcolor{green} & \cellcolor{black} & \cellcolor{black} &
    \cellcolor{black} & \cellcolor{black} & \cellcolor{black} &
    \cellcolor{black} \\ \hline
    \cellcolor{green} & \cellcolor{green} & \cellcolor{green} &
    \cellcolor{green} & \cellcolor{black} & \cellcolor{black} &
    \cellcolor{black} & \cellcolor{black} & \cellcolor{black} &
    \cellcolor{black} \\ \hline
    \cellcolor{green} & \cellcolor{green} & \cellcolor{green} &
    \cellcolor{green} & \cellcolor{green} & \cellcolor{black} &
    \cellcolor{black} & \cellcolor{black} & \cellcolor{black} &
    \cellcolor{black} \\ \hline
    \cellcolor{green} & \cellcolor{green} & \cellcolor{green} &
    \cellcolor{green} & \cellcolor{green} & \cellcolor{green} &
    \cellcolor{green} & \cellcolor{green} & \cellcolor{green} &
    \cellcolor{black} \\ \hline
  \end{tabular}
  }
&
  {\footnotesize
\setlength{\tabcolsep}{2.5pt}
  \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|}
    \hline
    0 & 0 & 0 & 0 & 0 & 4 & 4 & 4 & 4 & 4 \\ \hline
    1 & 1 & 0 & 0 & 0 & 3 & 4 & 4 & 4 & 4 \\ \hline
    1 & 1 & 1 & 0 & 0 & 3 & 4 & 4 & 4 & 4 \\ \hline
    1 & 1 & 1 & 0 & 0 & 3 & 4 & 4 & 4 & 4 \\ \hline
    1 & 1 & 1 & 0 & 0 & 3 & 3 & 4 & 4 & 3 \\ \hline
    1 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ \hline
    1 & 1 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\ \hline
    1 & 1 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\ \hline
    1 & 1 & 1 & 1 & 1 & 0 & 0 & 0 & 0 & 0 \\ \hline
    1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 0 \\ \hline
  \end{tabular}
  }
\end{tabular}
    \caption{Interpreting a PNG map image into a two-dimensional array}
\end{figure}

Values are then further separated into two-dimensional arrays consisting of
only each individual value.  Those arrays are then used to generate tiles and
some game entities within the gameworld.

\section{Generating level objects}
As explained previously, our game is a top-down 2D action game. Important to
note is the top-down 2D aspect of it when we are to generate our levels.
A historical and still prevalent technique for 2D games, is using a
tiling approach for the layout of both the backdrop of the level and entities
within it. Several different approaches to tiling have been used in games,
including squares, isometric and hexagonal tiles. Figure(insert figure)
show examples of historical games using each of the mentioned techniques of
tiling.
\\
\\
Insert fig
\\
\\
Since the individual techniques mostly impact the visual appearance of the game
- the underlying data structures remain the same - we have simply chosen the
most straightforward tile technique: square tiles.
\\
\\
The first naive implementation we prototyped was to iterate through the
two-dimensional maps and place tiles corresponding to the values. Specifically,
we need to place \texttt{sprites} in the gameworld. Sprites needs to be
assigned a \texttt{sprite renderer} component which in turn needs to be
attached a \texttt{gameobject}. This effectively means that for each tile, we
have to instantiate a gameobject. Figure(insert fig) shows a representation of
this using a shaded wireframe rendering so that each tile can be seen.
\\
\\
Insert fig
\\
\\
Since tiles exhibit no particular behavior, it seems excessive to instantiate
gameobjects for each tile. No only that, but we were experiencing performance
implications on mobile devices using this method.
